<!DOCTYPE html>
<html>

<head>
  <title>Extension Authors Guide</title>
  <script id="adobe_dtm" src="//www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlightjs-pack.js" type="text/javascript"></script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/assets/css/main.css" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="https://quarkus.io//feed.xml" title="Quarkus">
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-NJWS5L');</script>
  <!-- End Google Tag Manager -->
  <!-- Syntax highlighting -->
  <script>hljs.initHighlightingOnLoad();</script>
</head>

<body class="guides">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJWS5L"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div class="content">
    <div class="navigation-wrapper">
  <div class="width-12-12">
    <div class="header navigation">
      <div class="logo-wrapper">
        <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
      </div>
      <div class="nav-container">
        <nav>
          <div class="nav-mobile"><a id="nav-toggle" href="#!"><span></span></a></div>
          <ul class="nav-list">
            <li>
              <a href="/get-started/" class="">Get Started</a>
            </li>
            <li>
              <a href="/guides/" class="active">Guides</a>
            </li>
            <li>
              <a href="/extensions/" class="">Extensions</a>
            </li>
            <li>
              <a href="/community/" class="">Community</a>
            </li>
            <li>
              <a href="/blog/" class="">Blog</a>
            </li>
          </ul>
        </nav>
      </div>
    </div>
  </div>
</div>

    <div class="guides">
  <div class="width-12-12">
    <h1 class="text-caps">Extension Authors Guide</h1>
    <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#extension-philosophy">1. Extension philosophy</a>
<ul class="sectlevel2">
<li><a href="#why-an-extension-framework">1.1. Why an extension framework</a></li>
<li><a href="#favor-build-time-work-over-runtime-work">1.2. Favor build time work over runtime work</a></li>
<li><a href="#how-to-expose-configuration">1.3. How to expose configuration</a></li>
<li><a href="#expose-your-components-via-cdi">1.4. Expose your components via CDI</a></li>
<li><a href="#some-types-of-extensions">1.5. Some types of extensions</a></li>
</ul>
</li>
<li><a href="#technical-aspect">2. Technical aspect</a>
<ul class="sectlevel2">
<li><a href="#three-phases-of-bootstrap-and-quarkus-philosophy">2.1. Three Phases of Bootstrap and Quarkus Philosophy</a></li>
<li><a href="#maven-setup">2.2. Maven setup</a></li>
<li><a href="#build-step-processors">2.3. Build Step Processors</a></li>
<li><a href="#configuration">2.4. Configuration</a></li>
<li><a href="#bytecode-recording">2.5. Bytecode Recording</a></li>
<li><a href="#contexts-and-dependency-injection">2.6. Contexts and Dependency Injection</a></li>
<li><a href="#testing-extensions">2.7. Testing Extensions</a></li>
<li><a href="#native-executable-support">2.8. Native Executable Support</a></li>
<li><a href="#ide-support-tips">2.9. IDE support tips</a></li>
<li><a href="#troubleshooting-debugging-tips">2.10. Troubleshooting / Debugging Tips</a></li>
<li><a href="#sample-test-extension">2.11. Sample Test Extension</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus extensions add a new developer focused behavior to the core offering, and consist of two distinct parts, buildtime augmentation and runtime container. The augmentation part is responsible for all metadata processing, such as reading annotations, XML descriptors etc. The output of this augmentation phase is recorded bytecode which is responsible for directly instantiating the relevant runtime services.</p>
</div>
<div class="paragraph">
<p>This means that metadata is only processed once at build time, which both saves on startup time, and also on memory
usage as the classes etc that are used for processing are not loaded (or even present) in the runtime JVM.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extension-philosophy">1. Extension philosophy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section is a work in progress and gathers the philosophy under which extensions should be designed and written.</p>
</div>
<div class="sect2">
<h3 id="why-an-extension-framework">1.1. Why an extension framework</h3>
<div class="paragraph">
<p>Quarkus’s mission is to transform your entire application including the libraries it uses, into an artifact optimized for GraalVM.
To do this you need to analyze and understand the full "closed world" of the application.
Without the full and complete context, the best that can be achieved is partial and limited generic support.
By using the Quarkus extension approach, we can bring Java applications in line with memory footprint constrained environments like Kubernetes or cloud platforms.</p>
</div>
<div class="paragraph">
<p>The Quarkus extension framework results in significantly improved resource utilization even when GraalVM is not used (e.g. in HotSpot).
Let’s list the actions an extension performs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gather build time metadata and generate code</p>
<div class="ulist">
<ul>
<li>
<p>This part has nothing to do with GraalVM, it is how Quarkus starts frameworks “at build time”</p>
</li>
<li>
<p>The extension framework facilitates reading metadata, scanning classes as well as generating classes as needed</p>
</li>
<li>
<p>A small part of the extension work is executed at runtime via the generated classes, while the bulk of the work is done at build time (called deployment time)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Enforce opinionated and sensible defaults based on the close world view of the application (e.g. an application with no <code>@Entity</code> does not need to start Hibernate ORM)</p>
</li>
<li>
<p>An extension hosts Substrate VM code substitution so that libraries can run on GraalVM</p>
<div class="ulist">
<ul>
<li>
<p>Most changes are pushed upstream to help the underlying library run on GraalVM</p>
</li>
<li>
<p>Not all changes can be pushed upstream, extensions host Substrate VM substitutions - which is a form of code patching - so that libraries can run</p>
</li>
</ul>
</div>
</li>
<li>
<p>Host Substrate VM code substitution to help dead code elimination based on the application needs</p>
<div class="ulist">
<ul>
<li>
<p>This is application dependant and cannot really be shared in the library itself</p>
</li>
<li>
<p>For example, Quarkus optimizes the Hibernate code because it knows it only needs a specific connection pool and cache provider</p>
</li>
</ul>
</div>
</li>
<li>
<p>Send metadata to GraalVM for example classes in need of reflection</p>
<div class="ulist">
<ul>
<li>
<p>This information is not static per library (e.g. Hibernate) but the framework has the semantic knowledge and knows which classes need to have reflection (for example @Entity classes)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="favor-build-time-work-over-runtime-work">1.2. Favor build time work over runtime work</h3>
<div class="paragraph">
<p>As much as possible favor doing work at build time (deployment part of the extension) as opposed to let the framework do work at startup time (runtime).
The more is done there, the smaller Quarkus applications using that extension will be and the faster they will load.</p>
</div>
</div>
<div class="sect2">
<h3 id="how-to-expose-configuration">1.3. How to expose configuration</h3>
<div class="paragraph">
<p>Quarkus simplifies the most common usages.
This means that its defaults might be different than the library it integrates.</p>
</div>
<div class="paragraph">
<p>To make the simple experience easiest, unify the configuration in <code>application.properties</code> via MicroProfile Config.
Avoid library specific configuration files, or at least make them optional: e.g. <code>persistence.xml</code> for Hibernate ORM is optional.</p>
</div>
<div class="paragraph">
<p>Extensions should see the configuration holistically as a Quarkus application instead of focusing on the library experience.
For example <code>quarkus.database.url</code> and friends are shared between extensions as defining a database access is a shared task (instead of a <code>hibernate.</code> property for example).
The most useful configuration options should be exposed as <code>quarkus.[extension].</code> instead of the natural namespace of the library.
Less common properties can live in the library namespace.</p>
</div>
<div class="paragraph">
<p>To fully enable the close world assumptions that Quarkus can optimize best, it is better to consider configuration options as build time settled vs overridable at runtime.
Of course properties like host, port, password should be overridable at runtime.
But many properties like enable caching or setting the JDBC driver can safely require a rebuild of the application.</p>
</div>
</div>
<div class="sect2">
<h3 id="expose-your-components-via-cdi">1.4. Expose your components via CDI</h3>
<div class="paragraph">
<p>Since CDI is the central programming model when it comes to component composition, frameworks should expose producers that are easily consumable by user applications.<br>
For example, Hibernate ORM exposes <code>EntityManagerFactory</code> and <code>EntityManager</code> beans, the connection pool exposes <code>DataSource</code> beans etc.
An extension must generate these bean definitions at build time.</p>
</div>
<div class="sect3">
<h4 id="how-to-override-a-bean-defined-by-a-libraryquarkus-extension">1.4.1. How to Override a Bean Defined by a Library/Quarkus Extension</h4>
<div class="paragraph">
<p>The recommended approach is to mark your bean as a CDI <code>@Alternative</code> that is enabled using the <code>@Priority</code> annotation.
Let&#8217;s show a simple example.
Suppose we work on an imaginary "quarkus-parser" extension and we have a default bean implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@Dependent
class Parser {

  String[] parse(String expression) {
    return expression.split("::");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And our extension also consumes this parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@ApplicationScoped
class ParserService {

  @Inject
  Parser parser;

  //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, if a user or even some other extension needs to override the default implementation of the <code>Parser</code> the simplest solution is to use CDI <code>@Alternative</code> + <code>@Priority</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@Alternative <b class="conum">(1)</b>
@Priority(1) <b class="conum">(2)</b>
@Singleton
class MyParser extends Parser {

  String[] parse(String expression) {
    // my super impl...
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>MyParser</code> is an alternative bean.</p>
</li>
<li>
<p>Enables the alternative. The priority could be any number to override the default bean but if there are multiple alternatives the highest priority wins.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
CDI alternatives are only considered during injection and type-safe resolution. For example the default implementation would still receive observer notifications.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="some-types-of-extensions">1.5. Some types of extensions</h3>
<div class="paragraph">
<p>There exist multiple stereotypes of extension, let&#8217;s list a few.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Bare library running</dt>
<dd>
<p>This is the less sophisticated extension.
It consists of a set of patches to make sure a library runs on GraalVM.
If possible, contribute these patches upstream, not in extensions.
Second best is to write Substrate VM substitutions, which are patches applied during native image compilation.</p>
</dd>
<dt class="hdlist1">Get a framework running</dt>
<dd>
<p>A framework at runtime typically reads configuration, scan the classpath and classes for metadata (annotations, getters etc), build a metamodel on top of which it runs, find options via the service loader pattern, prepare invocation calls (reflection), proxy interfaces, etc.<br>
These operations should be done at build time and the metamodel be passed to the template DSL that will generate classes are runtime and boot the framework.</p>
</dd>
<dt class="hdlist1">Get a CDI portable extension running</dt>
<dd>
<p>The CDI portable extension model is very flexible.
Too flexible to benefit from the build time boot promoted by Quarkus.
Most extension we have seen do not make use of these extreme flexibilities capabilities.
The way to port a CDI extension to Quarkus is to rewrite it as a Quarkus extension which will define the various beans at build time (deployment time in extension parley).</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="technical-aspect">2. Technical aspect</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="three-phases-of-bootstrap-and-quarkus-philosophy">2.1. Three Phases of Bootstrap and Quarkus Philosophy</h3>
<div class="paragraph">
<p>There are three distinct bootstrap phases of a Quarkus app:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Augmentation</dt>
<dd>
<p>This is the first phase, and is done by the <a href="#build-step-processors">Build Step Processors</a>. These processors have access to Jandex annotation
information and can parse any descriptors and read annotations, but should not attempt to load any application classes. The output of these
build steps is some recorded bytecode, using an extension of the ObjectWeb ASM project called Gizmo(ext/gizmo), that is used to actually bootstrap the application at runtime. Depending on the <code>io.quarkus.deployment.annotations.ExecutionTime</code> value of the <code>@io.quarkus.deployment.annotations.Record</code> annotation associated with the build step,
the step may be run in a different JVM based on the following two modes.</p>
</dd>
<dt class="hdlist1">Static Init</dt>
<dd>
<p>If bytecode is recorded with <code>@Record(STATIC_INIT)</code> then it will be executed from a static init method on the main
class. For a native executable build, this code is executed in a normal JVM as part of the native build
process, and any retained objects that are produced in this stage will be directly serialized into the native executable via an image mapped file.
This means that if a framework can boot in this phase then it will have its booted state directly written to the
image, and so the boot code does not need to be executed when the image is started.</p>
<div class="paragraph">
<p>There are some restrictions on what can be done in this stage as the Substrate VM disallows some objects in the native executable. For example you should not attempt to listen on a port or start threads in this phase.</p>
</div>
<div class="paragraph">
<p>In non-native pure JVM mode, there is no real difference between Static and Runtime Init, except that Static Init is always executed first. This mode benefits from the same build phase augmentation as native mode as the descriptor parsing and annotation scanning are done
at build time and any associated class/framework dependencies can be removed from the build output jar. In servers like
WildFly, deployment related classes such as XML parsers hang around for the life of the application, using up valuable
memory. Quarkus aims to eliminate this, so that the only classes loaded at runtime are actually used at runtime.</p>
</div>
<div class="paragraph">
<p>As an example, the only reason that a Quarkus application should load an XML parser is if the user is using XML in their
application. Any XML parsing of configuration should be done in the Augmentation phase.</p>
</div>
</dd>
<dt class="hdlist1">Runtime Init</dt>
<dd>
<p>If bytecode is recorded with <code>@Record(RUNTIME_INIT)</code> then it is executed from the application&#8217;s main method. This code
will be run on native executable boot. In general as little code as possible should be executed in this phase, and should
be restricted to code that needs to open ports etc.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Pushing as much as possible into the <code>@Record(STATIC_INIT)</code> phase allows for two different optimizations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In both native executable and pure JVM mode this allows the app to start as fast as possible since processing was done during build time. This also minimizes the classes/native code needed in the application to pure runtime related behaviors.</p>
</li>
<li>
<p>Another benefit with native executable mode is that Substrate can more easily eliminate features that are not used. If features are directly initialized via bytecode, Substrate can detect that a method is never called and eliminate
that method. If config is read at runtime, Substrate cannot reason about the contents of the config and so needs to keep all features in case they are required.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="maven-setup">2.2. Maven setup</h3>
<div class="paragraph">
<p>Your extension project should be setup as a multi-module project with two submodules:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A deployment time submodule that handles the build time processing and bytecode recording.</p>
</li>
<li>
<p>A runtime submodule that contains the runtime behavior that will provide the extension behavior in the native executable or runtime JVM.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your runtime artifact should depend on <code>io.quarkus:quarkus-core</code>, and possibly the runtime artifacts of other Quarkus
modules if you want to use functionality provided by them.
You will also need to include the <code>io.quarkus:quarkus-bootstrap-maven-plugin</code> to generate the Quarkus extension descriptor included into the runtime artifact, if you are using the Quarkus parent pom it will automatically inherit the correct configuration.
Futhermore, you&#8217;ll need to configure the <code>maven-compiler-plugin</code> to detect the <code>quarkus-extension-processor</code> annotation processor.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
By convention the deployment time artifact has the <code>-deployment</code> suffix, and the runtime artifact
has no suffix (and is what the end user adds to their project).
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="xml" class="language-xml hljs">&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-core&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-bootstrap-maven-plugin&lt;/artifactId&gt;
            &lt;!-- Executions configuration can be inherited from quarkus-build-parent --&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;extension-descriptor&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                         &lt;deployment&gt;${project.groupId}:${project.artifactId}-deployment:${project.version}&lt;/deployment&gt;
                   &lt;/configuration&gt;
               &lt;/execution&gt;
           &lt;/executions&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;annotationProcessorPaths&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                        &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;
                    &lt;/path&gt;
                &lt;/annotationProcessorPaths&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The above <code>maven-compiler-plugin</code> configuration requires version 3.5+.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Under no circumstances can the runtime module depend on a deployment artifact. This would result
in pulling all the deployment time code into runtime scope, which defeats the purpose of having the split.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your deployment time module should depend on <code>io.quarkus:quarkus-core-deployment</code>, your runtime artifact,
and possibly the deployment artifacts of other Quarkus modules if you want to use functionality provided by them.
You will also need to configure the <code>maven-compiler-plugin</code> to detect the <code>quarkus-extension-processor</code> annotation processor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="xml" class="language-xml hljs">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-core-deployment&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;annotationProcessorPaths&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                        &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;
                    &lt;/path&gt;
                &lt;/annotationProcessorPaths&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="build-step-processors">2.3. Build Step Processors</h3>
<div class="paragraph">
<p>Work is done at deployment time by producing and consuming instances of <code>io.quarkus.builder.item.BuildItem</code>. This is done
by creating a class that has method(s) annotated with <code>io.quarkus.deployment.annotations.BuildStep</code>. These classes can
consume items by injection, and produce items by either returning them from the method or by injecting an
instance of <code>io.quarkus.deployment.annotations.BuildProducer</code> for the produced type. These processors can also record
bytecode invocations, which is mapped to a <code>BuildItem</code> transparently.</p>
</div>
<div class="paragraph">
<p>There are two distinct types of <code>BuildItem</code>, <code>SimpleBuildItem</code> and <code>MultiBuildItem</code>. <code>SimpleBuildItem</code> will only ever
have a single instance created, while <code>MultiBuildItem</code> can have many instances.</p>
</div>
<div class="paragraph">
<p>Injection can be done either via field injection, or via method parameter injection. Injection is used to set up
dependencies between build steps. For example if you inject a <code>List&lt;ServletBuildItem&gt;</code> your build step will not be called
until all possible producers of <code>ServletBuildItem</code> have been called. Injected objects are only valid during a <code>@BuildStep</code>
method invocation, once the method is complete they are no longer valid.</p>
</div>
<div class="paragraph">
<p>The following items are valid for injection:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SimpleBuildItem</code> instances (at some point we may support <code>Optional&lt;SimpleBuildItem&gt;</code>, but it is not implemented yet)</p>
</li>
<li>
<p><code>List&lt;? extends MultiBuildItem&gt;</code> instances</p>
</li>
<li>
<p><code>BuildProducer&lt;? extends BuildItem&gt;</code> instances</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a method returns a <code>BuildItem</code>, or injects a <code>BuildProducer</code> it is considered to be a producer of that item type,
while if it injects the item or list of items it is a consumer.</p>
</div>
<div class="paragraph">
<p>Note that a <code>@BuildStep</code> method will only be called if it produces something that another consumer or the final output
requires. If there is no consumer for a particular item then it will not be produced. What is required will depend on
the final target that is being produced, for example when running in developer mode the final output will not ask
for Substrate-specific build items such as <code>ReflectiveClassBuildItem</code> so methods that only produce Substrate specific
items will not be invoked.</p>
</div>
<div class="paragraph">
<p>Note that private methods and fields are not allowed, as injection is resolved at compile time via an annotation processor,
and the resulting code does not have permission to inject private fields or invoke private methods.</p>
</div>
<div class="paragraph">
<p><code>BuildItem</code> instances should be immutable, as the producer/consumer model does not allow for mutation to be correctly
ordered. This is not enforced but failure to adhere to this can result in race conditions.</p>
</div>
<div class="sect3">
<h4 id="capabilities">2.3.1. Capabilities</h4>
<div class="paragraph">
<p>The <code>@BuildStep</code> annotation has a <code>providesCapabilities</code> property that can be used to provide capability information
to other extensions about what is present in the current application. Capabilities are simply strings that are used to
describe an extension. Capabilities should generally be named after an extensions root package, for example the transactions
extension will provide <code>io.quarkus.transactions</code>.</p>
</div>
<div class="paragraph">
<p>To check if a capability is present you can inject the <code>io.quarkus.deployment.Capabilities</code> object and call
<code>isCapabilityPresent</code>.</p>
</div>
<div class="paragraph">
<p>Capabilities should be used when checking for the presence of an extension rather than class path based checks.</p>
</div>
</div>
<div class="sect3">
<h4 id="application-archives">2.3.2. Application Archives</h4>
<div class="paragraph">
<p>The <code>@BuildStep</code> annotation can also register marker files that determine which archives on the class path are considered
to be 'Application Archives', and will therefore get indexed. This is done via the <code>applicationArchiveMarkers</code>. For
example the ArC extension registers <code>META-INF/beans.xml</code>, which means that all archives on the class path with a <code>beans.xml</code>
file will be indexed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration">2.4. Configuration</h3>
<div class="paragraph">
<p>Configuration in Quarkus is based on SmallRye Config, an implementation of the MicroProfile Config specification.
All of the standard features of MP-Config are supported; in addition, there are several extensions which are made available
by the SmallRye Config project as well as by Quarkus itself.</p>
</div>
<div class="paragraph">
<p>The value of these properties is configured in a <code>application.properties</code> file that follows the MicroProfile config format.</p>
</div>
<div class="paragraph">
<p>Configuration of Quarkus extensions is injection-based, using annotations.</p>
</div>
<div class="sect3">
<h4 id="configuration-keys">2.4.1. Configuration Keys</h4>
<div class="paragraph">
<p>Leaf configuration keys are mapped to non-<code>private</code> fields via the <code>@io.quarkus.runtime.annotations.ConfigItem</code> annotation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Though the SmallRye Config project is used for implementation, the standard <code>@ConfigProperty</code> annotation does not have the
same semantics that are needed to support configuration within extensions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Configuration keys are normally derived from the field names that they are tied to.  This is done by de-camel-casing the name and then
joining the segments with hyphens (<code>-</code>).  Some examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bindAddress</code> becomes <code>bind-address</code></p>
</li>
<li>
<p><code>keepAliveTime</code> becomes <code>keep-alive-time</code></p>
</li>
<li>
<p><code>requestDNSTimeout</code> becomes <code>request-dns-timeout</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The name can also be explicitly specified by giving a <code>name</code> attribute to the <code>@ConfigItem</code> annotation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Though it is possible to override the configuration key name using the <code>name</code> attribute of <code>@ConfigItem</code>,
normally this should only be done in cases where (for example) the configuration key name is the same as a Java keyword.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="configuration-value-types">2.4.2. Configuration Value types</h4>
<div class="paragraph">
<p>The type of the field with the <code>@ConfigItem</code> annotation determines the conversion that is applied to it.  Quarkus
extensions may use the full range of configuration types made available by SmallRye Config, which includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All primitive types and primitive wrapper types</p>
</li>
<li>
<p><code>String</code></p>
</li>
<li>
<p>Any type which has a constructor accepting a single argument of type <code>String</code> or <code>CharSequence</code></p>
</li>
<li>
<p>Any type which has a static method named <code>of</code> which accepts a single argument of type <code>String</code></p>
</li>
<li>
<p>Any type which has a static method named <code>valueOf</code> or <code>parse</code> which accepts a single argument of type <code>CharSequence</code> or <code>String</code></p>
</li>
<li>
<p>A <code>List</code> or <code>Optional</code> of any of the above types</p>
</li>
<li>
<p><code>OptionalInt</code>, <code>OptionalLong</code>, <code>OptionalDouble</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, custom converters may be registered by build extensions using the <code>io.quarkus.deployment.builditem.ConfigurationCustomConverterBuildItem</code>
class.</p>
</div>
<div class="paragraph">
<p>Though these implicit converters use reflection, Quarkus will automatically ensure that they are loaded at the appropriate time.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuration-groups">2.4.3. Configuration Groups</h4>
<div class="paragraph">
<p>Configuration values are always collected into grouping classes which are marked with the <code>@io.quarkus.runtime.annotations.ConfigGroup</code>
annotation.  These classes contain a field for each key within its group.  In addition, configuration groups can be nested.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuration-maps">2.4.4. Configuration Maps</h4>
<div class="paragraph">
<p>A <code>Map</code> can be used for configuration at any position where a configuration group would be allowed.  The key type of such a
map <strong>must</strong> be <code>String</code>, and its value may be either a configuration group class or a valid leaf type.  The configuration
key segment following the map&#8217;s key segment will be used as the key for map values.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuration-roots">2.4.5. Configuration Roots</h4>
<div class="paragraph">
<p>Configuration roots are configuration groups that appear in the root of the configuration tree.  A configuration property&#8217;s full
name is determined by joining the string <code>quarkus.</code> with the hyphenated name of the fields that form the path from the root to the
leaf field.  For example, if I define a configuration root group called <code>ThreadPool</code>, with a nested group in a field named <code>sizing</code>
that in turn contains a field called <code>minSize</code>, the final configuration property will be called <code>quarkus.thread-pool.sizing.min-size</code>.</p>
</div>
<div class="paragraph">
<p>A configuration root&#8217;s name can be given with the <code>name</code> property, or it can be inferred from the class name.  If the latter,
then the configuration key will be the class name, minus any <code>Config</code> or <code>Configuration</code> suffix, broken up by camel-case,
lowercased, and re-joined using hyphens (<code>-</code>).</p>
</div>
<div class="paragraph">
<p>Note: The current implementation is still using injection site to determine the root set, so to avoid migration problems, it
is recommended that the injection site (field or parameter) have the same name as the configuration root class until
this change is complete.</p>
</div>
<div class="sect4">
<h5 id="configuration-root-phases">2.4.5.1. Configuration Root Phases</h5>
<div class="paragraph">
<p>A configuration root dictates when its contained keys are read from configuration, and when they are available to applications.  The phases defined by <code>io.quarkus.runtime.annotations.ConfigPhase</code> are as follows:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 53.3336%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Phase name</th>
<th class="tableblock halign-center valign-top">Read &amp; avail. at build time</th>
<th class="tableblock halign-center valign-top">Avail. at run time</th>
<th class="tableblock halign-center valign-top">Read during static init</th>
<th class="tableblock halign-center valign-top">Re-read during startup (native executable)</th>
<th class="tableblock halign-left valign-top">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BUILD_TIME</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Appropriate for things which affect build.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BUILD_AND_RUN_TIME_FIXED</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Appropriate for things which affect build and must be visible for run time code.  Not read from config at run time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RUN_TIME_STATIC</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not available at build, read on start in JVM mode, fixed in native executable mode.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RUN_TIME</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not available at build, read at start in all modes.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For all cases other than the <code>BUILD_TIME</code> case, the configuration root class and all of the configuration groups and types contained therein must be located in, or reachable from, the extension&#8217;s run time artifact.  Configuration roots of phase <code>BUILD_TIME</code> may be located in or reachable from either of the extension&#8217;s run time or deployment artifacts.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuration-example">2.4.6. Configuration Example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">import io.quarkus.runtime.annotations.ConfigItem;
import io.quarkus.runtime.annotations.ConfigGroup;

import java.io.File;
import java.util.logging.Level;

@ConfigGroup <b class="conum">(1)</b>
public class FileConfig {

    /**
     * Enable file logging.
     */
    @ConfigItem(defaultValue = "true")
    boolean enable;

    /**
     * The log format.
     */
    @ConfigItem(defaultValue = "%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{1.}] (%t) %s%e%n")
    String format;

    /**
     * The file log level.
     */
    @ConfigItem(defaultValue = "ALL")
    Level level;

    /**
     * The file logging log level.
     */
    @ConfigItem(defaultValue = "quarkus.log")
    File path;

}

/**
 * Logging configuration.
 */
@ConfigRoot(phase = ConfigPhase.RUN_TIME) <b class="conum">(2)</b>
public class LogConfiguration {

    // ...

    /**
     * Configuration properties for the logging file handler.
     */
    FileConfig file;
}

public class LoggingProcessor {
    // ...

    /**
     * Logging configuration.
     */
    <b class="conum">(3)</b>
    LogConfiguration config;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>FileConfig</code> class is annotated with <code>@ConfigGroup</code> to indicate that this is an aggregate
configuration object containing a collection of configurable properties, rather than being a simple configuration
key type.</p>
</li>
<li>
<p>The <code>@ConfigRoot</code> annotation indicates that this object is a configuration root group, whose property names will have a parent only of <code>quarkus.</code>.  In this case the properties within the group will begin with <code>quarkus.log.*</code>.</p>
</li>
<li>
<p>Here the <code>LoggingProcessor</code> injects a <code>LogConfiguration</code> instance automatically by detecting the <code>@ConfigRoot</code> annotation.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A corresponding <code>application.properties</code> file for the <code>File</code> values could be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="properties" class="language-properties hljs">quarkus.log.file.enable=true
quarkus.log.file.level=DEBUG
quarkus.log.file.path=/tmp/debug.log</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bytecode-recording">2.5. Bytecode Recording</h3>
<div class="paragraph">
<p>One of the main outputs of the build process is recorded bytecode. This bytecode actually sets up the runtime environment. For example, in order to start Undertow, the resulting application will have some bytecode that directly registers all
Servlet instances and then starts Undertow.</p>
</div>
<div class="paragraph">
<p>As writing bytecode directly is incredibly complex, this is instead done via bytecode recorders. At deployment time, invocations
are made on proxy instances of template objects that contain the actual runtime logic, and these invocations are recorded,
including the value of method parameters. Bytecode is then created to do these same invocations on the actual template
object at runtime.</p>
</div>
<div class="paragraph">
<p>In more detail, a processor class from the extensions deployment module gathers the configuration
information within a <code>@BuildStep</code> method that is also annotated with a <code>@Record(STATIC_INIT)</code> or  <code>@Record(RUNTIME_INIT)</code> annotation along with injection of a <code>@Template</code> annotated class
from the runtime module. A class annotated with <code>@Template</code> is known as a template because it
provides a template of methods to configure a runtime service. The value of template that is
injected into the deployment class is a proxy of the template, and any method invocations that are made will be recorded, and output as bytecode that will be run at application startup.</p>
</div>
<div class="paragraph">
<p>Methods on a template can return a value, which must be proxiable (if you want to return a non-proxiable item wrap it
in <code>io.quarkus.runtime.RuntimeValue</code>). These proxies may not be invoked directly, however they can be passed
into other template methods. This can be any template method, including from other <code>@Record</code> methods, so a common pattern
is to produce <code>BuildItem</code> instances that wrap the results of these template invocations.</p>
</div>
<div class="paragraph">
<p>For instance, in order to make arbitrary changes to a Servlet deployment Undertow has a <code>ServletExtensionBuildItem</code>,
which is a <code>MultiBuildItem</code> that wraps a <code>ServletExtension</code> instance. I can return a <code>ServletExtension</code> from a template
in another module, and Undertow will consume it and pass it into the template method that starts Undertow.</p>
</div>
<div class="paragraph">
<p>At runtime the bytecode will be invoked in the order it is generated. This means that build step dependencies implicitly
control the order that generated bytecode is run. In the example above we know that the bytecode that produces a
<code>ServletExtensionBuildItem</code> will be run before the bytecode that consumes it.</p>
</div>
<div class="sect3">
<h4 id="recordercontext">2.5.1. RecorderContext</h4>
<div class="paragraph">
<p><code>io.quarkus.deployment.recording.RecorderContext</code> provides some convenience methods to enhance bytecode recording,
this includes the ability to register creation functions for classes without no-arg constructors, to register an object
substitution (basically a transformer from a non-serializable object to a serializable one and vice versa), and to create
a class proxy. This interface can be directly injected as a method parameter into any <code>@Record</code> method.</p>
</div>
<div class="paragraph">
<p>Calling <code>classProxy</code> with a given class name will create a <code>Class</code> that can be passed into template
methods, and at runtime will be substituted with the class whose name was passed in to <code>classProxy</code>. This is basically a
convenience to avoid the need to explicitly load classes in the templates.</p>
</div>
<div class="paragraph">
<p>TODO: config integration</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="contexts-and-dependency-injection">2.6. Contexts and Dependency Injection</h3>
<div class="sect3">
<h4 id="extension-points">2.6.1. Extension Points</h4>
<div class="paragraph">
<p>As a CDI based runtime, Quarkus extensions often make CDI beans available as part of the extension behavior.
However, Quarkus DI solution does not support CDI Portable Extensions.
Instead, Quarkus extensions can make use of various <a href="cdi-reference.html">Build Time Extension Points</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing-extensions">2.7. Testing Extensions</h3>
<div class="paragraph">
<p>Testing of extensions should be done with the <code>io.quarkus.test.QuarkusUnitTest</code> runner. This runner allows
for Arquillian-style tests that test specific functionalities. It is not intended for testing user applications, as this
should be done via <code>io.quarkus.test.junit.QuarkusTest</code>. The main difference between these test runners is that
<code>QuarkusTest</code> simply boots the application once at the start of the run, while <code>QuarkusUnitTest</code> deploys a custom
Quarkus application for each test class.</p>
</div>
<div class="paragraph">
<p>These tests should be placed in the deployment module, if additional Quarkus modules are required for testing
their deployment modules should also be added as test scoped dependencies.</p>
</div>
<div class="paragraph">
<p>Note that <code>QuarkusUnitTest</code> is in the <code>quarkus-junit5-internal</code> module.</p>
</div>
<div class="paragraph">
<p>An example test class may look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package io.quarkus.health.test;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.List;

import javax.enterprise.inject.Instance;
import javax.inject.Inject;

import org.eclipse.microprofile.health.Health;
import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import io.quarkus.test.QuarkusUnitTest;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

import io.restassured.RestAssured;

public class FailingUnitTest {


    @RegisterExtension                                                                  // <b class="conum">(1)</b>
    static final QuarkusUnitTest config = new QuarkusUnitTest()
            .setArchiveProducer(() -&gt;
                    ShrinkWrap.create(JavaArchive.class)                                // <b class="conum">(2)</b>
                            .addClasses(FailingHealthCheck.class)
                            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml")
            );
    @Inject                                                                             // <b class="conum">(3)</b>
    @Health
    Instance&lt;HealthCheck&gt; checks;

    @Test
    public void testHealthServlet() {
        RestAssured.when().get("/health").then().statusCode(503);                       // <b class="conum">(4)</b>
    }

    @Test
    public void testHealthBeans() {
        List&lt;HealthCheck&gt; check = new ArrayList&lt;&gt;();                                    // <b class="conum">(5)</b>
        for (HealthCheck i : checks) {
            check.add(i);
        }
        assertEquals(1, check.size());
        assertEquals(HealthCheckResponse.State.DOWN, check.get(0).call().getState());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This tells JUnit to use the Quarkus unit test runner</p>
</li>
<li>
<p>This producer is used to build the application to be tested. It uses Shrinkwrap to create a JavaArchive to test</p>
</li>
<li>
<p>It is possible to inject beans from our test deployment directly into the test case</p>
</li>
<li>
<p>This method directly invokes the health check Servlet and verifies the response</p>
</li>
<li>
<p>This method uses the injected health check bean to verify it is returning the expected result</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you want to test that an extension properly fails at build time, use the <code>setExpectedException</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package io.quarkus.hibernate.orm;

import io.quarkus.deployment.configuration.ConfigurationError;
import io.quarkus.test.QuarkusUnitTest;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

public class PersistenceAndQuarkusConfigTest {

    @RegisterExtension
    static QuarkusUnitTest runner = new QuarkusUnitTest()
            .setExpectedException(ConfigurationError.class)                     <b class="conum">(1)</b>
            .setArchiveProducer(() -&gt; ShrinkWrap.create(JavaArchive.class)
                    .addAsManifestResource("META-INF/some-persistence.xml", "persistence.xml")
                    .addAsResource("application.properties"));

    @Test
    public void testPersistenceAndConfigTest() {
        // should not be called, deployment exception should happen first:
        // it's illegal to have Hibernate configuration properties in both the
        // application.properties and in the persistence.xml
        Assertions.fail();
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This tells JUnit that the Quarkus deployment should fail with a specific exception</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="native-executable-support">2.8. Native Executable Support</h3>
<div class="paragraph">
<p>There Quarkus provides a lot of build items that control aspects of the native executable build. This allows for extensions
to programmatically perform tasks such as registering classes for reflection or adding static resources to the native
executable. Some of these build items are listed below:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.substrate.SubstrateResourceBuildItem</code></dt>
<dd>
<p>Includes static resources into the native executable.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.substrate.RuntimeReinitializedClassBuildItem</code></dt>
<dd>
<p>A class that will be reinitialized at runtime by Substrate. This will result in the static initializer running twice.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.substrate.SubstrateSystemPropertyBuildItem</code></dt>
<dd>
<p>A system property that will be set at native executable build time.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.substrate.SubstrateResourceBundleBuildItem</code></dt>
<dd>
<p>Includes a resource bundle in the native executable.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.substrate.ReflectiveClassBuildItem</code></dt>
<dd>
<p>Registers a class for reflection in Substrate. Constructors are always registered, while methods and fields are optional.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.substrate.RuntimeInitializedClassBuildItem</code></dt>
<dd>
<p>A class that will be initialized at runtime rather than build time. This will cause the build to fail if the class is initialized as part of the native executable build process, so care must be taken.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.substrate.SubstrateConfigBuildItem</code></dt>
<dd>
<p>A convenience feature that allows you to control most of the above features from a single build item.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="ide-support-tips">2.9. IDE support tips</h3>
<div class="sect3">
<h4 id="writing-quarkus-extensions-in-eclipse">2.9.1. Writing Quarkus extensions in Eclipse</h4>
<div class="paragraph">
<p>The only particular aspect of writing Quarkus extensions in Eclipse is that APT (Annotation Processing Tool) is required as part of extension builds, which means you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Install <code>m2e-apt</code> from <a href="https://marketplace.eclipse.org/content/m2e-apt" class="bare">https://marketplace.eclipse.org/content/m2e-apt</a></p>
</li>
<li>
<p>Define this property in your <code>pom.xml</code>: <code>&lt;m2e.apt.activation&gt;jdt_apt&lt;/m2e.apt.activation&gt;</code>, although if you rely on <code>io.quarkus:quarkus-build-parent</code> you will get it for free.</p>
</li>
<li>
<p>If you have the <code>io.quarkus:quarkus-extension-processor</code> project open at the same time in your IDE (for example, if you have the Quarkus sources checked out and open in your IDE) you will need to close that project. Otherwise, Eclipse will not invoke the APT plugin that it contains.</p>
</li>
<li>
<p>If you just closed the extension processor project, be sure to do <code>Maven &gt; Update Project</code> on the other projects in order for Eclipse to pick up the extension processor from the Maven repository.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="troubleshooting-debugging-tips">2.10. Troubleshooting / Debugging Tips</h3>
<div class="sect3">
<h4 id="saving-application-generated-classes-to-disk">2.10.1. Saving Application Generated Classes to Disk</h4>
<div class="paragraph">
<p>The class augmentation step of Quarkus generates classes for various purposes. Sometimes you need to view these
classes/bytecode to debug or understand an issue. Classes that are related to application augmentation are currently held in
memory in a runtime class loader. To have these classes written out to disk for inspection, specify the
<code>quarkus.debug.generated-classes-dir</code> system property, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">./mvnw clean install -Dquarkus.debug.generated-classes-dir=./target/app-generated-classes</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sample-test-extension">2.11. Sample Test Extension</h3>
<div class="paragraph">
<p>We have an extension that is used to test for regressions in the extension processing. It is located in <a href="https://github.com/quarkusio/quarkus/tree/master/core/test-extension" class="bare">https://github.com/quarkusio/quarkus/tree/master/core/test-extension</a> directory. In this section we touch on some of the tasks an extension
author will typically need to perform using the test-extension code to illustrate how the task could be done.</p>
</div>
<div class="sect3">
<h4 id="features-and-capabilities">2.11.1. Features and Capabilities</h4>
<div class="paragraph">
<p>When you start a Quarkus instance, you will see a line like the one highlighted in this example:</p>
</div>
<div class="listingblock">
<div class="title">Example Startup Lines</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 0.061s.
2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Installed features: [cdi, test-extension] <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A list of features installed in the runtime image</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The features listed reflect the types of extensions that are installed. An extension declares its display name
 using a <a href="#build-step-processors">Build Step Processors</a> method that produces a <code>FeatureBuildItem</code> like this TestProcessor#featureBuildItem() method example:</p>
</div>
<div class="listingblock">
<div class="title">TestProcessor#featureBuildItem()</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">    /**
     * Register a extension capability and feature
     *
     * @return test-extension feature build item
     */
    @BuildStep(providesCapabilities = "io.quarkus.test-extension")
    FeatureBuildItem featureBuildItem() {
        return new FeatureBuildItem("test-extension");
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The feature name should map to a label in the extension&#8217;s devtools/common/src/main/filtered/extensions.json entry so that
the feature name displayed by the startup line matches a label that one can used to select the extension when creating a project
using the Quarkus maven plugin as shown in this example taken from the Writing JSON REST Services guide where the "resteasy-jsonb" feature is referenced:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">mvn io.quarkus:quarkus-maven-plugin:0.15.0:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=rest-json \
    -DclassName="org.acme.rest.json.FruitResource" \
    -Dpath="/fruits" \
    -Dextensions="resteasy-jsonb"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bean-defining-annotations">2.11.2. Bean Defining Annotations</h4>
<div class="paragraph">
<p>The CDI layer processes CDI beans that are either explicitly registered or that it discovers based on bean defining annotations as defined in <a href="http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations"&gt;">2.5.1. Bean defining annotations</a>. You can expand this set of annotations to include annotations your extension processes using a <code>BeanDefiningAnnotationBuildItem</code> as shown in this <code>TestProcessor#registerBeanDefinningAnnotations</code> example:</p>
</div>
<div class="listingblock">
<div class="title">Register a Bean Definining Annotation</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.enterprise.context.ApplicationScoped;
import org.jboss.jandex.DotName;
import io.quarkus.extest.runtime.TestAnnotation;

public final class TestProcessor {
    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());
    static DotName TEST_ANNOTATION_SCOPE = DotName.createSimple(ApplicationScoped.class.getName());

...

    @BuildStep
    BeanDefiningAnnotationBuildItem registerX() {
        <b class="conum">(1)</b>
        return new BeanDefiningAnnotationBuildItem(TEST_ANNOTATION, TEST_ANNOTATION_SCOPE);
    }
...
}

/**
 * Marker annotation for test configuration target beans
 */
@Target({ TYPE })
@Retention(RUNTIME)
@Documented
@Inherited
public @interface TestAnnotation {
}

/**
 * A sample bean
 */
@TestAnnotation <b class="conum">(2)</b>
public class ConfiguredBean implements IConfigConsumer {

...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Register the annotation class and CDI default scope using the Jandex <code>DotName</code> class.</p>
</li>
<li>
<p><code>ConfiguredBean</code> will be processed by the CDI layer the same as a bean annotated with the CDI standard @ApplicationScoped.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="parsing-config-to-objects">2.11.3. Parsing Config to Objects</h4>
<div class="paragraph">
<p>One of the main things an extension is likely to do is completely separate the configuration phase of behavior from the runtime phase. Frameworks often do parsing/load of configuration on startup that can be done during build time to both reduce the runtime dependencies on frameworks like xml parsers as well as reducing the startup time the parsing incurs.</p>
</div>
<div class="paragraph">
<p>An example of parsing a XML config file using JAXB is shown in the <code>TestProcessor#parseServiceXmlConfig</code> method:
.Parsing an XML Configuration into Runtime XmlConfig Instance</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">    @BuildStep
    @Record(STATIC_INIT)
    RuntimeServiceBuildItem parseServiceXmlConfig(TestTemplate template) throws JAXBException {
        RuntimeServiceBuildItem serviceBuildItem = null;
        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        InputStream is = getClass().getResourceAsStream("/config.xml"); <b class="conum">(1)</b>
        if (is != null) {
            log.infof("Have XmlConfig, loading");
            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is); <b class="conum">(2)</b>
...
        }
        return serviceBuildItem;
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Look for a config.xml classpath resource</p>
</li>
<li>
<p>If found, parse using JAXB context for <code>XmlConfig.class</code></p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>If there was no /config.xml resource available in the build environment, then a null <code>RuntimeServiceBuildItem</code> would be returned and no subsequent logic based on a <code>RuntimeServiceBuildItem</code> being produced would execute.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Typically one is loading a configuration to create some runtime component/service as <code>parseServiceXmlConfig</code> is doing. We will come back to the rest of the behavior in <code>parseServiceXmlConfig</code> in the following <a href="#manage-non-cdi-service">Manage Non-CDI Service</a> section.</p>
</div>
<div class="paragraph">
<p>If for some reason you need to parse the config and use it in other build steps in an extension processor, you would need to create an <code>XmlConfigBuildItem</code> to pass the parsed XmlConfig instance around.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you look at the XmlConfig code you will see that it does carry around the JAXB annotations. If you don&#8217;t want these in the runtime image, you could clone the XmlConfig instance into some POJO object graph and then replace XmlConfig with the POJO class. We will do this in <a href="#replacing-classes-in-the-native-image">Replacing Classes in the Native Image</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scanning-deployments-using-jandex">2.11.4. Scanning Deployments Using Jandex</h4>
<div class="paragraph">
<p>If your extension defines annotations or interfaces that mark beans needing to be processed, you can locate these beans using the Jandex API, a Java annotation indexer and offline reflection library. The following <code>TestProcessor#scanForBeans</code> method shows how to find the beans annotated with our <code>@TestAnnotation</code> that also implement the <code>IConfigConsumer</code> interface:</p>
</div>
<div class="listingblock">
<div class="title">Example Jandex Usage</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());
...

    @BuildStep
    @Record(STATIC_INIT)
    void scanForBeans(TestTemplate template, BeanArchiveIndexBuildItem beanArchiveIndex, <b class="conum">(1)</b>
            BuildProducer&lt;TestBeanBuildItem&gt; testBeanProducer) {
        IndexView indexView = beanArchiveIndex.getIndex(); <b class="conum">(2)</b>
        Collection&lt;AnnotationInstance&gt; testBeans = indexView.getAnnotations(TEST_ANNOTATION); <b class="conum">(3)</b>
        for (AnnotationInstance ann : testBeans) {
            ClassInfo beanClassInfo = ann.target().asClass();
            try {
                boolean isConfigConsumer = beanClassInfo.interfaceNames()
                        .stream()
                        .anyMatch(dotName -&gt; dotName.equals(DotName.createSimple(IConfigConsumer.class.getName()))); <b class="conum">(4)</b>
                if (isConfigConsumer) {
                    Class&lt;IConfigConsumer&gt; beanClass = (Class&lt;IConfigConsumer&gt;) Class.forName(beanClassInfo.name().toString());
                    testBeanProducer.produce(new TestBeanBuildItem(beanClass)); <b class="conum">(5)</b>
                    log.infof("Configured bean: %s", beanClass);
                }
            } catch (ClassNotFoundException e) {
                log.warn("Failed to load bean class", e);
            }
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Depend on a <code>BeanArchiveIndexBuildItem</code> to have the build step be run after the deployment has been indexed.</p>
</li>
<li>
<p>Retrieve the index.</p>
</li>
<li>
<p>Find all beans annotated with <code>@TestAnnotation</code>.</p>
</li>
<li>
<p>Determine which of these beans also has the <code>IConfigConsumer</code> interface.</p>
</li>
<li>
<p>Save the bean class in a <code>TestBeanBuildItem</code> for use in a latter RUNTIME_INIT build step that will interact with the bean instances.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="interacting-with-extension-beans">2.11.5. Interacting With Extension Beans</h4>
<div class="paragraph">
<p>You can use the <code>io.quarkus.arc.runtime.BeanContainer</code> interface to interact with your extension beans. The following <code>configureBeans</code> methods illustrate interacting with the beans scanned for in the previous section:</p>
</div>
<div class="listingblock">
<div class="title">Using CDI BeanContainer Interface</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// TestProcessor#configureBeans
    @BuildStep
    @Record(RUNTIME_INIT)
    void configureBeans(TestTemplate template, List&lt;TestBeanBuildItem&gt; testBeans, <b class="conum">(1)</b>
            BeanContainerBuildItem beanContainer, <b class="conum">(2)</b>
            TestRunTimeConfig runTimeConfig) {

        for (TestBeanBuildItem testBeanBuildItem : testBeans) {
            Class&lt;IConfigConsumer&gt; beanClass = testBeanBuildItem.getConfigConsumer();
            template.configureBeans(beanContainer.getValue(), beanClass, buildAndRunTimeConfig, runTimeConfig); <b class="conum">(3)</b>
        }
    }

// TestTemplate#configureBeans
    public void configureBeans(BeanContainer beanContainer, Class&lt;IConfigConsumer&gt; beanClass,
            TestBuildAndRunTimeConfig buildTimeConfig,
            TestRunTimeConfig runTimeConfig) {
        log.infof("Begin BeanContainerListener callback\n");
        IConfigConsumer instance = beanContainer.instance(beanClass); <b class="conum">(4)</b>
        instance.loadConfig(buildTimeConfig, runTimeConfig); <b class="conum">(5)</b>
        log.infof("configureBeans, instance=%s\n", instance);
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Consume the `TestBeanBuildItem`s produced from the scanning build step.</p>
</li>
<li>
<p>Consume the <code>BeanContainerBuildItem</code> to order this build step to run after the CDI bean container has been created.</p>
</li>
<li>
<p>Call the runtime template to record the bean interactions.</p>
</li>
<li>
<p>Runtime template retrieves the bean using its type.</p>
</li>
<li>
<p>Runtime template invokes the <code>IConfigConsumer#loadConfig(&#8230;&#8203;)</code> method passing in the configuration objects with runtime information.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="manage-non-cdi-service">2.11.6. Manage Non-CDI Service</h4>
<div class="paragraph">
<p>A common purpose for an extension is to integrate a non-CDI aware service into the CDI based Quarkus runtime. Step 1 of this task is to load any configuration needed in a STATIC_INIT build step as we did in <a href="#parsing-config-to-objects">Parsing Config to Objects</a>. Now we need to create an instance of the service using the configuration. Let&#8217;s return to the <code>TestProcessor#parseServiceXmlConfig</code> method to see how this can be done.</p>
</div>
<div class="listingblock">
<div class="title">Creating a Non-CDI Service</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// TestProcessor#parseServiceXmlConfig
    @BuildStep
    @Record(STATIC_INIT)
    RuntimeServiceBuildItem parseServiceXmlConfig(TestTemplate template) throws JAXBException {
        RuntimeServiceBuildItem serviceBuildItem = null;
        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        InputStream is = getClass().getResourceAsStream("/config.xml");
        if (is != null) {
            log.infof("Have XmlConfig, loading");
            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is);
            log.infof("Loaded XmlConfig, creating service");
            RuntimeValue&lt;RuntimeXmlConfigService&gt; service = template.initRuntimeService(config); //<b class="conum">(1)</b>
            serviceBuildItem = new RuntimeServiceBuildItem(service); //<b class="conum">(3)</b>
        }
        return serviceBuildItem;
    }

// TestTemplate#initRuntimeService
    public RuntimeValue&lt;RuntimeXmlConfigService&gt; initRuntimeService(XmlConfig config) {
        RuntimeXmlConfigService service = new RuntimeXmlConfigService(config); //<b class="conum">(2)</b>
        return new RuntimeValue&lt;&gt;(service);
    }

// RuntimeServiceBuildItem
    final public class RuntimeServiceBuildItem extends SimpleBuildItem {
    private RuntimeValue&lt;RuntimeXmlConfigService&gt; service;

    public RuntimeServiceBuildItem(RuntimeValue&lt;RuntimeXmlConfigService&gt; service) {
        this.service = service;
    }

    public RuntimeValue&lt;RuntimeXmlConfigService&gt; getService() {
        return service;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Call into the runtime template to record the creation of the service.</p>
</li>
<li>
<p>Using the parsed <code>XmlConfig</code> instance, create an instance of <code>RuntimeXmlConfigService</code> and wrap it in a <code>RuntimeValue</code>. Use a <code>RuntimeValue</code> wrapper for non-interface objects that are non-proxiable.</p>
</li>
<li>
<p>Wrap the return service value in a <code>RuntimeServiceBuildItem</code> for use in a RUNTIME_INIT build step that will start the service.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="starting-a-service">2.11.6.1. Starting a Service</h5>
<div class="paragraph">
<p>Now that you have recorded the creation of a service during the build phase, you need to record how to start the service at runtime during booting. You do this with a RUNTIME_INIT build step as shown in the <code>TestProcessor#startRuntimeService</code> method.</p>
</div>
<div class="listingblock">
<div class="title">Starting/Stopping a Non-CDI Service</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// TestProcessor#startRuntimeService
    @BuildStep
    @Record(RUNTIME_INIT)
    ServiceStartBuildItem startRuntimeService(TestTemplate template, ShutdownContextBuildItem shutdownContextBuildItem , // <b class="conum">(1)</b>
            RuntimeServiceBuildItem serviceBuildItem) throws IOException { // <b class="conum">(2)</b>
        if (serviceBuildItem != null) {
            log.info("Registering service start");
            template.startRuntimeService(shutdownContextBuildItem, serviceBuildItem.getService()); // <b class="conum">(3)</b>
        } else {
            log.info("No RuntimeServiceBuildItem seen, check config.xml");
        }
        return new ServiceStartBuildItem("RuntimeXmlConfigService"); //<b class="conum">(4)</b>
    }

// TestTemplate#startRuntimeService
    public void startRuntimeService(ShutdownContext shutdownContext, RuntimeValue&lt;RuntimeXmlConfigService&gt; runtimeValue)
            throws IOException {
        RuntimeXmlConfigService service = runtimeValue.getValue();
        service.startService(); //<b class="conum">(5)</b>
        shutdownContext.addShutdownTask(service::stopService); //<b class="conum">(6)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We consume a ShutdownContextBuildItem to register the service shutdown.</p>
</li>
<li>
<p>We consume the previously initialized service captured in <code>RuntimeServiceBuildItem</code>.</p>
</li>
<li>
<p>Call the runtime template to record the service start invocation.</p>
</li>
<li>
<p>Produce a <code>ServiceStartBuildItem</code> to indicate the startup of a service. See <a href="#startup-and-shutdown-events">Startup and Shutdown Events</a> for details.</p>
</li>
<li>
<p>Runtime template retrieves the service instance reference and calls its <code>startService</code> method.</p>
</li>
<li>
<p>Runtime template registers an invocation of the service instance <code>stopService</code> method with the Quarkus <code>ShutdownContext</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The code for the <code>RuntimeXmlConfigService</code> can be viewed here:
{quarkus-blob-url}/core/test-extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]</p>
</div>
<div class="paragraph">
<p>The testcase for validating that the <code>RuntimeXmlConfigService</code> has started can be found in the <code>testRuntimeXmlConfigService</code> test of <code>ConfiguredBeanTest</code> and <code>NativeImageIT</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="startup-and-shutdown-events">2.11.7. Startup and Shutdown Events</h4>
<div class="paragraph">
<p>The Quarkus container supports startup and shutdown lifecycle events to notify components of the container startup
and shutdown. There are CDI events fired that components can observe are illustrated in this example:</p>
</div>
<div class="listingblock">
<div class="title">Observing Container Startup</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import io.quarkus.runtime.ShutdownEvent;
import io.quarkus.runtime.StartupEvent;

puclic class SomeBean {
    /**
     * Called when the runtime has started
     * @param event
     */
    void onStart(@Observes StartupEvent event) { // <b class="conum">(1)</b>
        System.out.printf("onStart, event=%s%n", event);
    }

    /**
     * Called when the runtime is shutting down
     * @param event
    */
    void onStop(@Observes ShutdownEvent event) { // <b class="conum">(2)</b>
        System.out.printf("onStop, event=%s%n", event);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Observe a <code>StartupEvent</code> to be notified the runtime has started.</p>
</li>
<li>
<p>Observe a 'ShutdownEvent` to be notified when the runtime is going to shutdown.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>What is the relevance of startup and shutdown events for extension authors? We have already seen the use of a <code>ShutdownContext</code>
to register a callback to perform shutdown tasks in the <a href="#starting-a-service">Starting a Service</a> section. These shutdown tasks would be called
after a <code>ShutdownEvent</code> had been sent.</p>
</div>
<div class="paragraph">
<p>A <code>StartupEvent</code> is fired after all <code>io.quarkus.deployment.builditem.ServiceStartBuildItem</code> producers have been consumed.
The implication of this is that if an extension has services that application components would expect to have been
started when they observe a <code>StartupEvent</code>, the build steps that invoke the runtime code to start those services needs
to produce a <code>ServiceStartBuildItem</code> to ensure that the runtime code is run before the <code>StartupEvent</code> is sent. Recall that
we saw the production of a <code>ServiceStartBuildItem</code> in the previous section, and it is repeated here for clarity:</p>
</div>
<div class="listingblock">
<div class="title">Example of Producing a ServiceStartBuildItem</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// TestProcessor#startRuntimeService
    @BuildStep
    @Record(RUNTIME_INIT)
    ServiceStartBuildItem startRuntimeService(TestTemplate template, ShutdownContextBuildItem shutdownContextBuildItem,
            RuntimeServiceBuildItem serviceBuildItem) throws IOException {
...
        return new ServiceStartBuildItem("RuntimeXmlConfigService"); //<b class="conum">(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Produce a <code>ServiceStartBuildItem</code> to indicate that this is a service starting step that needs to run before the <code>StartupEvent</code> is sent.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="register-resources-for-use-in-native-image">2.11.8. Register Resources for Use in Native Image</h4>
<div class="paragraph">
<p>Not all configuration or resources can be consumed at build time. If you have classpath resources that the runtime needs to access, you need to inform the build phase that these resources need to be copied into the native image. This is done by producing one or more <code>SubstrateResourceBuildItem</code> or <code>SubstrateResourceBundleBuildItem</code> in the case of resource bundles. Examples of this are shown in this sample <code>registerNativeImageReources</code> build step:</p>
</div>
<div class="listingblock">
<div class="title">Registering Resources and ResourceBundles</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public final class MyExtProcessor {
    @Inject
    BuildProducer&lt;SubstrateResourceBuildItem&gt; resource;
    @Inject
    BuildProducer&lt;SubstrateResourceBundleBuildItem&gt; resourceBundle;

    @BuildStep
    void registerNativeImageReources() {
        resource.produce(new SubstrateResourceBuildItem("/security/runtime.keys")); //<b class="conum">(1)</b>

        resource.produce(new SubstrateResourceBuildItem(
                "META-INF/services/" + io.quarkus.SomeService.class.getName())); //<b class="conum">(2)</b>

        resourceBundle.produce(new SubstrateResourceBuildItem("javax.xml.bind.Messages")); //<b class="conum">(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicate that the /security/runtime.keys classpath resource should be copied into native image.</p>
</li>
<li>
<p>Indicate that the <code>io.quarkus.SomeService</code> ServiceLoader resource should be copied into native image.</p>
</li>
<li>
<p>Indicate that the "javax.xml.bind.Messages" resource bundle should be copied into native image.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="object-substitution">2.11.9. Object Substitution</h4>
<div class="paragraph">
<p>Objects created during the build phase that are passed into the runtime need to have a default constructor in order for them to be created and configured at startup of the runtime from the build time state. If an object does not have a default constructor you will see an error similar to the following during generation of the augmented artifacts:</p>
</div>
<div class="listingblock">
<div class="title">DSAPublicKey Serialization Error</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">	[error]: Build step io.quarkus.deployment.steps.MainClassBuildStep#build threw an exception: java.lang.RuntimeException: Unable to serialize objects of type class sun.security.provider.DSAPublicKeyImpl to bytecode as it has no default constructor
	at io.quarkus.builder.Execution.run(Execution.java:123)
	at io.quarkus.builder.BuildExecutionBuilder.execute(BuildExecutionBuilder.java:136)
	at io.quarkus.deployment.QuarkusAugmentor.run(QuarkusAugmentor.java:110)
	at io.quarkus.runner.RuntimeRunner.run(RuntimeRunner.java:99)
	... 36 more</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a <code>io.quarkus.runtime.ObjectSubstitution</code> interface that can be implemented to tell Quarkus how to handle such classes. An example implementation for the <code>DSAPublicKey</code> is shown here:</p>
</div>
<div class="listingblock">
<div class="title">DSAPublicKeyObjectSubstitution Example</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">package io.quarkus.extest.runtime.subst;

import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.DSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.logging.Logger;

import io.quarkus.runtime.ObjectSubstitution;

public class DSAPublicKeyObjectSubstitution implements ObjectSubstitution&lt;DSAPublicKey, KeyProxy&gt; {
    private static final Logger log = Logger.getLogger("DSAPublicKeyObjectSubstitution");
    @Override
    public KeyProxy serialize(DSAPublicKey obj) { //<b class="conum">(1)</b>
        log.info("DSAPublicKeyObjectSubstitution.serialize");
        byte[] encoded = obj.getEncoded();
        KeyProxy proxy = new KeyProxy();
        proxy.setContent(encoded);
        return proxy;
    }

    @Override
    public DSAPublicKey deserialize(KeyProxy obj) { //<b class="conum">(2)</b>
        log.info("DSAPublicKeyObjectSubstitution.deserialize");
        byte[] encoded = obj.getContent();
        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encoded);
        DSAPublicKey dsaPublicKey = null;
        try {
            KeyFactory kf = KeyFactory.getInstance("DSA");
            dsaPublicKey = (DSAPublicKey) kf.generatePublic(publicKeySpec);

        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return dsaPublicKey;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The serialize method takes the object without a default constructor and creates a <code>KeyProxy</code> that contains the information necessary to recreate the <code>DSAPublicKey</code>.</p>
</li>
<li>
<p>The deserialize method uses the <code>KeyProxy</code> to recreate the <code>DSAPublicKey</code> from its encoded form using the key factory.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>An extension registers this substitution by producing an <code>ObjectSubstitutionBuildItem</code> as shown in this <code>TestProcessor#loadDSAPublicKey</code> fragment:</p>
</div>
<div class="listingblock">
<div class="title">Registering an Object Subtitution</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">    @BuildStep
    @Record(STATIC_INIT)
    PublicKeyBuildItem loadDSAPublicKey(TestTemplate template,
            BuildProducer&lt;ObjectSubstitutionBuildItem&gt; substitutions) throws IOException, GeneralSecurityException {
...
        // Register how to serialize DSAPublicKey
        ObjectSubstitutionBuildItem.Holder&lt;DSAPublicKey, KeyProxy&gt; holder = new ObjectSubstitutionBuildItem.Holder(
                DSAPublicKey.class, KeyProxy.class, DSAPublicKeyObjectSubstitution.class);
        ObjectSubstitutionBuildItem keysub = new ObjectSubstitutionBuildItem(holder);
        substitutions.produce(keysub);

        log.infof("loadDSAPublicKey run");
        return new PublicKeyBuildItem(publicKey);
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="replacing-classes-in-the-native-image">2.11.10. Replacing Classes in the Native Image</h4>
<div class="paragraph">
<p>The Graal SDK supports substitutions of classes in the native image. An example of how one could replace the <code>XmlConfig/XmlData</code> classes with versions that have no JAXB annotation dependencies is shown in these example classes:</p>
</div>
<div class="listingblock">
<div class="title">Substitution of XmlConfig/XmlData Classes Example</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">package io.quarkus.extest.runtime.graal;

import java.util.Date;

import com.oracle.svm.core.annotate.Substitute;
import com.oracle.svm.core.annotate.TargetClass;

import io.quarkus.extest.runtime.config.XmlData;
@TargetClass(XmlConfig.class)
@Substitute
final public class Target_XmlConfig {
    @Substitute
    private String address;
    @Substitute
    private int port;
    @Substitute
    private ArrayList&lt;XData&gt; dataList;

    @Substitute
    public String getAddress() {
        return address;
    }

    @Substitute
    public int getPort() {
        return port;
    }

    @Substitute
    public ArrayList&lt;XData&gt; getDataList() {
        return dataList;
    }

    @Substitute
    @Override
    public String toString() {
        return "Target_XmlConfig{" +
                "address='" + address + '\'' +
                ", port=" + port +
                ", dataList=" + dataList +
                '}';
    }
}

@TargetClass(XmlData.class)
@Substitute
final public class Target_XmlData {
    @Substitute
    private String name;
    @Substitute
    private String model;
    @Substitute
    private Date date;

    @Substitute
    public String getName() {
        return name;
    }

    @Substitute
    public String getModel() {
        return model;
    }

    @Substitute
    public Date getDate() {
        return date;
    }

    @Substitute
    @Override
    public String toString() {
        return "Target_XmlData{" +
                "name='" + name + '\'' +
                ", model='" + model + '\'' +
                ", date='" + date + '\'' +
                '}';
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
  </div>
</div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus is open. Quarkus and its extensions are available under the <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a> or compatible license.<br /><br />This website was built with <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a> is hosted on <a href='https://pages.github.com/' target='_blank'>Github Pages</a> and is completely open source. If you want to make it better, <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>fork the website</a> and show us what you’ve got.</p>

    
      <div class="width-1-12 project-links">
        <span>Navigation</span>
        <ul class="footer-links width-1-12">
          
            <li><a href="/">Home</a></li>
          
            <li><a href="/guides">Guides</a></li>
          
            <li><a href="/get-started">Get Started</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Contribute</span>
        <ul class="footer-links width-1-12">
          
            <li><a href="https://twitter.com/quarkusio">Follow us</a></li>
          
            <li><a href="https://github.com/quarkusio">GitHub</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Get Help</span>
        <ul class="footer-links width-1-12">
          
            <li><a href="https://quarkusio.zulipchat.com">Chatroom</a></li>
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev">Google&nbsp;Groups</a></li>
          
            <li><a href="/faq">FAQ</a></li>
          
        </ul>
      </div>
    

    
      <div class="width-6-12 more-links">
        <span>Quarkus is proudly made of</span>
        <ul class="footer-links">
          
            <li><a href="https://hibernate.org" target="_blank">Hibernate</a></li>
          
            <li><a href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
        </ul>
      </div>
    
  </div>
</div>
  <div class="content redhat-footer">
  <div class="grid-wrapper">
    <span class="licence">
      <i class="fab fa-creative-commons"></i><i class="fab fa-creative-commons-by"></i> <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC by 3.0</a>
      | <a href="https://www.redhat.com/en/about/privacy-policy">Red Hat Privacy Policy</a>
    </span>
    <span class="redhat">
      a Red Hat sponsored project   
    </span>
    <span class="redhat-logo">
      <a href="https://www.redhat.com/" target="_blank"><img src="/assets/images/redhat_reversed.svg"></a>
    </span>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script type="text/javascript">
    if (("undefined" !== typeof _satellite) && ("function" === typeof _satellite.pageBottom)) {
        _satellite.pageBottom();
    }
  </script>
</body>

</html>
